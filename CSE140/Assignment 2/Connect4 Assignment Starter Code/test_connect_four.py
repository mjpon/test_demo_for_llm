# Generated by CodiumAI

import pytest
import ConnectFour
import Player

"""
Code Analysis

Main functionalities:
The Game class is responsible for creating a GUI for the Connect 4 game and handling the logic of making a move in the game. It takes in two player objects and a time limit for AI players, and creates a GUI with a canvas for the game board and a button for making moves. The class also contains methods for updating the game board, checking if the game is over, and determining the current player.

Methods:
- __init__(self, player1, player2, time): initializes the Game object with two player objects and a time limit for AI players, creates a GUI for the game board, and sets up the canvas and button for making moves.
- make_move(self): handles the logic of making a move in the game, including checking if the game is over, determining the current player, and calling the appropriate method to get the move.
- update_board(self, move, player_num): updates the game board with the current player's move and checks if the move is valid.
- game_completed(self, player_num): checks if the game is over by checking for horizontal, vertical, and diagonal wins.

Fields:
- players: a list of the two player objects.
- colors: a list of the colors used to represent the players on the game board.
- current_turn: an integer representing the index of the current player in the players list.
- board: a numpy array representing the game board.
- gui_board: a list of lists representing the game board on the GUI.
- game_over: a boolean indicating if the game is over.
- ai_turn_limit: an integer representing the time limit for AI players to make a move.
"""


class TestGame:
    #  Tests that the game initializes without errors
    def test_game_init(self):
        game = ConnectFour.Game(Player.RandomPlayer(1), Player.AIPlayer(2), 5)
        assert game.current_turn == 0
        assert game.board.shape == (6, 7)
        assert game.gui_board == []
        assert game.game_over == False
        assert game.ai_turn_limit == 5
        assert game.player_string['text'] == 'Random Player 1'

    #  Tests that a valid move updates the board and changes the current player
    def test_make_move_valid(self, mocker):
        game = ConnectFour.Game(Player.RandomPlayer(1), Player.AIPlayer(2), 5)
        mocker.patch.object(Player.RandomPlayer, 'get_move', return_value=0)
        mocker.patch.object(Player.AIPlayer, 'get_expectimax_move', return_value=1)
        game.make_move()
        assert game.current_turn == 1
        assert game.board[5][0] == 1
        assert game.gui_board[0][5] != None

    #  Tests that an invalid move raises an exception
    def test_make_move_invalid(self, mocker):
        game = ConnectFour.Game(Player.RandomPlayer(1), Player.AIPlayer(2), 5)
        mocker.patch.object(Player.RandomPlayer, 'get_move', return_value=0)
        mocker.patch.object(Player.AIPlayer, 'get_expectimax_move', return_value=1)
        game.make_move()
        with pytest.raises(Exception):
            game.make_move()

    #  Tests that the game ends when a player wins
    def test_game_over_win(self, mocker):
        game = Game(RandomPlayer(1), AIPlayer(2), 5)
        mocker.patch.object(RandomPlayer, 'get_move', return_value=0)
        mocker.patch.object(AIPlayer, 'get_expectimax_move', return_value=1)
        game.board = np.array([[1, 1, 1, 0, 0, 0, 0],
                               [2, 2, 1, 0, 0, 0, 0],
                               [2, 1, 2, 0, 0, 0, 0],
                               [2, 2, 1, 0, 0, 0, 0],
                               [2, 1, 2, 0, 0, 0, 0],
                               [1, 2, 1, 0, 0, 0, 0]])
        game.make_move()
        assert game.game_over == True
        assert game.player_string['text'] == 'Random Player 1 wins!'

    #  Tests that the game ends in a tie
    def test_game_over_tie(self, mocker):
        game = Game(RandomPlayer(1), AIPlayer(2), 5)
        mocker.patch.object(RandomPlayer, 'get_move', side_effect=[0, 1, 2, 3, 4, 5, 6,
                                                                   6, 5, 4, 3, 2, 1, 0,
                                                                   0, 1, 2, 3, 4, 5, 6,
                                                                   6, 5, 4, 3, 2, 1, 0,
                                                                   0, 1, 2, 3, 4, 5, 6,
                                                                   6, 5, 4, 3, 2, 1, 0,
                                                                   3, 4, 2, 5, 1, 6])
        mocker.patch.object(AIPlayer, 'get_expectimax_move', side_effect=[0] * 42)
        game.board = np.array([[1, 2, 1, 2, 1, 2, 1],
                               [2, 1, 2, 1, 2, 1, 2],
                               [1, 2, 1, 2, 1, 2, 1],
                               [2, 1, 2, 1, 2, 1, 2],
                               [1, 2, 1, 2, 1, 2, 1],
                               [2, 1, 2, 1, 2, 1, 2]])
        for i in range(42):
            game.make_move()
        assert game.game_over == True
        assert game.player_string['text'] == 'Tie!'

    #  Tests that an AI player exceeding the time limit raises an exception
    def test_ai_time_limit(self):
        game = Game(AIPlayer(1), RandomPlayer(2), 0.01)
        with pytest.raises(Exception):
            game.make_move()
